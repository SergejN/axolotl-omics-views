#!/usr/bin/env perl

#   File:
#       Pathway.pm
#
#   Description:
#       Contains the Pathway analysis module of the Axolotl Transcriptome API (ATAPI).
#
#   Version:
#       1.0.1
#
#   Date:
#       20.05.2014
#
#   Copyright:
#       Dr. Sergej Nowoshilow, Research institute of molecular pathology, IMP, Vienna

use strict;
use warnings;

use Axolotl::ATAPI::Constants;


package Pathway;
{
    my $MODULE = 'Pathway';
    my $VERSION = '1.0.1';
    my $DATE = '2014-05-20';
    
    sub new
    {
        my $class = shift;
        my $self = {_db => undef, _fnAddNodes => undef};
        bless $self, $class;
        return $self;
    }
    
    # Common plug-in methods.
    sub init
    {
        my ($self, $hDB, $fnAddNodes, $ps) = @_;
        $self->{_db} = $hDB;
        $self->{_fnAddNodes} = $fnAddNodes;
        return $MODULE;
    }
    
    sub getDescription
    {
       return "Retrieves the details about the well-characterized pathways.";
    }
    
    sub getVersion
    {
	return {version => $VERSION, released => $DATE};
    }

    sub getDocumentation
    {
        my ($self, $refParams) = @_;
        my @arrMethods = ({_name => 'getList',
                           _description => 'Retrieves the list of available pathways',
                           _resultCode => [{_value => 'Constants::ERR_OK',
                                            _numval => Constants::ERR_OK,
                                            _description => 'If succeeds'}],
                           _sample => "$refParams->{_base}/api?method=$MODULE.getList"},

			  {_name => 'getPathwayDetails',
                           _description => 'Retrieves the details about the specified pathways: name, description and participating genes',
                           _args => [{_name => 'pathways',
                                      _description => 'Comma-separated list of pathway IDs',
                                      _type => 'required',
                                      _default => ''},
				     {_name => 'assembly',
                                      _description => 'Version of the assembly to use when retrieving the Axolotl homologs',
                                      _type => 'optional',
                                      _default => 'current assembly'}],
                           _resultCode => [{_value => 'Constants::ERR_OK',
                                            _numval => Constants::ERR_OK,
                                            _description => 'If succeeds'},
					   {_value => 'Constants::ERR_NOT_ENOUGH_PARAMETERS',
                                            _numval => Constants::ERR_NOT_ENOUGH_PARAMETERS,
                                            _description => 'If no pathway IDs were specified'},],
                           _sample => "$refParams->{_base}/api?method=$MODULE.getPathwayDetails&pathways=P04398",
			   _remarks => "If no pathway IDs are specified the behaviour of the method is identical with that of '$MODULE.getList'."},
			  
			  {_name => 'findPathways',
                           _description => 'Retrieves the list of pathways for each specified contig',
                           _args => [{_name => 'contigs',
                                      _description => 'Comma-separated list of contig IDs',
                                      _type => 'required',
                                      _default => ''}],
                           _resultCode => [{_value => 'Constants::ERR_OK',
                                            _numval => Constants::ERR_OK,
                                            _description => 'If succeeds'},
					   {_value => 'Constants::ERR_NOT_ENOUGH_PARAMETERS',
                                            _numval => Constants::ERR_NOT_ENOUGH_PARAMETERS,
                                            _description => 'If no contig IDs were specified'},],
                           _sample => "$refParams->{_base}/api?method=$MODULE.findPathways&contigs=NT_02200014625.1"});
        return \@arrMethods;
    }
       
    sub execute
    {
        my ($self, %hmParams) = @_;
        my $strMethod = $hmParams{_method};
        my $refMethodParams = $hmParams{_parameters};
        my $xmldoc = $hmParams{_xmldoc};
        my $xmldata = $hmParams{_xmldata};
        my $xmlerr = $hmParams{_xmlerr};
        # Execute the method.
	if($strMethod eq 'getList')
        {
            return $self->getList($refMethodParams, $xmldoc, $xmldata, $xmlerr);
        }
	elsif($strMethod eq 'getPathwayDetails')
        {
            return $self->getPathwayDetails($refMethodParams, $xmldoc, $xmldata, $xmlerr);
        }
	elsif($strMethod eq 'findPathways')
        {
            return $self->findPathways($refMethodParams, $xmldoc, $xmldata, $xmlerr);
        }
        else
        {
            $xmlerr->addChild($xmldoc->createTextNode("The method '$MODULE.$strMethod' was not found"));
            return Constants::ERR_METHOD_NOT_FOUND;
        }
    }
    
    sub getList
    {
        my ($self, $refParams, $xmldoc, $xmldata, $xmlerr) = @_;
	return $self->getPathwayDetails($refParams, $xmldoc, $xmldata, $xmlerr, 1);
    }
    
    sub getPathwayDetails
    {
	my ($self, $refParams, $xmldoc, $xmldata, $xmlerr, $bListAll) = @_;
	my $strQuery = "SELECT name, ".
			      "description ".
		       "FROM Pathway";
	if($refParams->{pathways} && !$bListAll)
	{
	    my @arrPathways = split(/,/, $refParams->{pathways});
	    foreach(@arrPathways)
	    {
		$_=~ s/'/\\'/g;
		$_ = "'$_'";
	    }
	    if((scalar @arrPathways)>0)
	    {
		$strQuery .= ' WHERE Pathway.name IN (' . (join(',', @arrPathways)) . ')';
	    }
	}
	my $a_id = undef;
	if(!$bListAll)
	{
	    my $strQuery = ($refParams->{assembly}) ? "SELECT a_id FROM Assembly WHERE version=" . (int($refParams->{assembly}))
						    : "SELECT a_id FROM Assembly WHERE version=(SELECT MAX(version) FROM Assembly)";
	    ($a_id) = $self->{_db}->selectrow_array($strQuery);
	    if(!$a_id)
	    {
		$strQuery = "SELECT a_id FROM Assembly WHERE version=(SELECT MAX(version) FROM Assembly)";
		($a_id) = $self->{_db}->selectrow_array($strQuery);
	    }
	}
	my $statement = $self->{_db}->prepare($strQuery);
	$statement->execute();
	while(my $refResult = $statement->fetchrow_hashref())
	{
	    my $pathway = $xmldoc->createElement('pathway');
	    $pathway->addChild($xmldoc->createAttribute(id => $refResult->{name}));
	    $pathway->addChild($xmldoc->createTextNode($refResult->{description}));
	    # Find all participating genes, if $bListAll is not set.
	    if(!$bListAll)
	    {
		my $members = $xmldoc->createElement('members');
		my $strQuery = "SELECT RefSeq.seq_id AS rs_id, ".
				      "RefSeq.ens_id AS ens_id, ".
				      "RefSeq.upkb_id AS upkb_id, ".
				      "Contig.name AS cname, ".
				      "RefSeqOrganism.name AS rso_name ".
			       "FROM Contig ".
				    "INNER JOIN Alignment ON Contig.c_id=Alignment.c_id ".
				    "INNER JOIN RefSeq ON Alignment.rs_id=RefSeq.rs_id ".
				    "INNER JOIN PathwayMember ON RefSeq.rs_id=PathwayMember.rs_id ".
				    "INNER JOIN Pathway ON PathwayMember.pw_id=Pathway.pw_id ".
				    "INNER JOIN RefSeqOrganism ON RefSeq.rso_id=RefSeqOrganism.rso_id ".
			       "WHERE Pathway.name='$refResult->{name}' AND Contig.a_id=$a_id ORDER BY RefSeqOrganism.name";
		my $stMembers = $self->{_db}->prepare($strQuery);
		$stMembers->execute();
		my $refMember = $stMembers->fetchrow_hashref();
		my $strOrganism = $refMember->{rso_name};
		my $organism = $xmldoc->createElement($strOrganism);
		$members->addChild($organism);
		while($refMember)
		{
		    if($refMember->{rso_name} ne $strOrganism)
		    {
			$strOrganism = $refMember->{rso_name};
			$organism = $xmldoc->createElement($strOrganism);
			$members->addChild($organism);
		    }
		    my $member = $xmldoc->createElement('member');
		    $member->addChild($xmldoc->createAttribute(entrez => $refMember->{rs_id}));
		    $member->addChild($xmldoc->createAttribute(ensembl => $refMember->{ens_id}));
		    $member->addChild($xmldoc->createAttribute(uniprotkb => $refMember->{upkb_id}));
		    $member->addChild($xmldoc->createAttribute(contig => $refMember->{cname}));
		    $organism->addChild($member);
		    $refMember = $stMembers->fetchrow_hashref();
		}
		$pathway->addChild($members);
	    }
	    $xmldata->addChild($pathway);
	}
	return Constants::ERR_OK;
    }
    
    sub findPathways
    {
        my ($self, $refParams, $xmldoc, $xmldata, $xmlerr) = @_;
	my @arrContigs = (defined $refParams->{contigs}) ? split(/,/, $refParams->{contigs}) : ();
	if((scalar @arrContigs)==0)
        {
            $xmlerr->addChild($xmldoc->createTextNode("No contigs specified"));
            return Constants::ERR_NOT_ENOUGH_PARAMETERS;
        }
	foreach(@arrContigs)
	{
	    $_=~ s/'//g;
	    my $contig = $xmldoc->createElement('contig');
	    $contig->addChild($xmldoc->createAttribute(id => $_));
	    my $nAdded = 0;
	    # Find the homologous RefSeq sequences.
	    my $strQuery = "SELECT Pathway.name AS pwname, ".
				  "Pathway.description AS pwdesc ".
	                   "FROM Contig ".
			        "INNER JOIN Alignment ON Contig.c_id=Alignment.c_id ".
				"INNER JOIN RefSeq ON Alignment.rs_id=RefSeq.rs_id ".
				"INNER JOIN PathwayMember ON RefSeq.rs_id=PathwayMember.rs_id ".
				"INNER JOIN Pathway ON PathwayMember.pw_id=Pathway.pw_id ".
			   "WHERE Contig.name='$_' GROUP BY Pathway.name";	   
	    my $statement = $self->{_db}->prepare($strQuery);
	    $statement->execute();
	    while(my $refResult = $statement->fetchrow_hashref())
	    {
		my $pathway = $xmldoc->createElement('pathway');
		$pathway->addChild($xmldoc->createAttribute(id => $refResult->{pwname}));
		$pathway->addChild($xmldoc->createTextNode($refResult->{pwdesc}));
		$contig->addChild($pathway);
		$nAdded++;
	    }
	    $xmldata->addChild($contig) if($nAdded>0);
	}
	return Constants::ERR_OK;
    }
    
}

1;